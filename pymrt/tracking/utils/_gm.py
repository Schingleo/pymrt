import numpy as np
import scipy.stats
from scipy.spatial import distance


class GaussianComponent:
    r"""Gaussian Mixture Component

    A Gaussian mixture component is composed of weight (:math:`w`), mean vector
    (:math:`\mu`), and covariance matrix (:math:`\Sigma`).
    A multivariate Gaussian distribution :math:`\mathcal{N}(\mu, \Sigma)`
    evaluated at position :math:`x` is given by

    .. math::
        f(x) = \frac{1}{\sqrt{(2\pi) ^ k \left| \Sigma \right|}}
        e^{-\frac{1}{2} (x - \mu) ^ T \Sigma ^ {-1} (x - \mu)}

    A multivariate Gaussian Mixture Component, denoted
    :math:`\mathcal{N}(w, \mu, \Sigma)` is a equivalent to a multivariate
    Gaussian distribution with a weight factor,
    i.e. :math:`w \mathcal{N}(\mu, \Sigma)`.
    As a result, a GM evaluated at position :math:`x` is given by

    .. math::
        f_{GM}(x) = w f(x)

    where :math:`f(x)` is the density of a multivariate Gaussian distribution
    evaluated at location :math:`x`.

    Attributes:
        n (:obj:`int`): Dimensionality of the space the Gaussian component is
            evaluated on.
        weight (:obj:`float`): Weight of this Gaussian Component.
        mean (:obj:`numpy.ndarray`): Mean vector (column) :math:`\mu` of shape
            (n, 1).
        cov (:obj:`numpy.ndarray`): Covariance matrix of shape (n, n).
    """
    def __init__(self, n, weight, mean, cov):
        self.weight = weight
        self.mean = np.array(mean, dtype=np.float).reshape((n, 1))
        self.cov = np.array(cov, dtype=np.float).reshape((n, n))
        # Other values for Gaussian evaluation
        self.n = n

    def __str__(self):
        return "GM " + str(self.weight) + " @ " + str(self.mean.flatten()) + \
               " with cov " + str(self.cov)

    def dmvnorm(self, x):
        r"""Density of multivariate normal distribution evaluated at location x

        dmv_part1 calculates

        .. math::
            \frac{1}{\sqrt{(2\pi) ^ k \left| \Sigma \right|}}
            e^{-\frac{1}{2} (x - \mu) ^ T \Sigma ^ {-1} (x - \mu)}
        """
        # Cache the part that is not change with x
        dmv_part1 = np.power(((2.0 * np.pi) ** self.n) * np.linalg.det(
            self.cov), -0.5)
        invcov = np.linalg.inv(self.cov)
        dev = x - self.mean
        dmv_part2 = np.exp(-0.5 * np.dot(np.dot(dev.T, invcov), dev))
        return dmv_part1 * dmv_part2

    def dmvnormcomp_loc(self, x):
        return scipy.stats.multivariate_normal.pdf(
            x.flatten(),
            self.mean[0:2, :].flatten(),
            cov=self.cov[0:2, 0:2])

    def dmvnormcomp(self, x):
        """Density of multivariate GM component evaluated at location x
        """
        return self.weight * self.dmvnorm(x)

    def kalman_update(self, F, Q):
        r"""Update a GM Component based on a linear prediction model.

        Assume each target follows a linear Gaussian dynamic model:

        .. math::
            f_{k|k=1} (x|\eta) = N(x; F_{k-1}\eta, Q_{k-1})
        """
        self.mean = np.dot(F, self.mean)
        self.cov = np.dot(F, np.dot(self.cov, F.T)) + Q


def gm_calculate(gm_list, grid, approx_mode=False):
    """ Sample GM Multi-target PHD with a grid

    Args:
        gm_list (:obj:`list`): List of Gaussian components representing
            posterior probability hypothesis density of multiple targets.
        grid (:obj:`array`): Mesh grid typically generated by
            :meth:`numpy.mgrid` or :meth:`numpy.meshgrid` function.
        approx_mode (:obj:`bool`): Do not calculate PDF of a Gaussian Mixture
            component if the data is some distance away from the mean.

    Returns:
        (:obj:`dict`): Dictionary containing a plot with lines connecting
            observation and truth in the same frame. The dictionary contains
            the following keys:
    """
    grid_dim = len(grid)
    grid_flatten = [grid[d].flatten() for d in range(grid_dim)]
    phd_s_flatten = np.zeros(grid_flatten[0].shape)
    for k in range(len(gm_list)):
        gm_w = gm_list[k].weight
        gm_mean = gm_list[k].mean
        gm_cov = gm_list[k].cov
        max_cov = np.sqrt(np.max(np.diag(gm_cov)))
        gm_mean_point = gm_mean.flatten()[0:grid_dim]
        gm_rvs = scipy.stats.multivariate_normal(
            mean=gm_mean_point,
            cov=gm_cov[0:grid_dim, 0:grid_dim].T
        )
        for i in range(len(grid_flatten[0])):
            eva_point = np.array(
                [grid_flatten[j][i] for j in range(grid_dim)]
            ).flatten()
            if approx_mode is False or \
                    distance.euclidean(eva_point, gm_mean_point) <= \
                    10 * max_cov:
                # This is a hack for faster PDF calculation
                phd_s_flatten[i] += gm_w * np.exp(
                    gm_rvs._dist._logpdf(
                        eva_point,
                        gm_rvs.mean, gm_rvs.cov_info.U,
                        gm_rvs.cov_info.log_pdet, gm_rvs.cov_info.rank
                    )
                )
        # print(k)
    phd_s = phd_s_flatten.reshape(grid[0].shape)
    return phd_s
